module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBookPost {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateContributor {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateGitPost {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateSeries {
  count: Int!
}

type AggregateTopic {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type BookPost {
  id: ID!
  post: Post!
  bookName: String!
  bookPublisher: String!
  LinkedStore: [LinkedStore!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookPostConnection {
  pageInfo: PageInfo!
  edges: [BookPostEdge]!
  aggregate: AggregateBookPost!
}

input BookPostCreateInput {
  id: ID
  post: PostCreateOneWithoutBookPostsInput!
  bookName: String!
  bookPublisher: String!
  LinkedStore: BookPostCreateLinkedStoreInput
}

input BookPostCreateLinkedStoreInput {
  set: [LinkedStore!]
}

input BookPostCreateOneWithoutPostInput {
  create: BookPostCreateWithoutPostInput
  connect: BookPostWhereUniqueInput
}

input BookPostCreateWithoutPostInput {
  id: ID
  bookName: String!
  bookPublisher: String!
  LinkedStore: BookPostCreateLinkedStoreInput
}

type BookPostEdge {
  node: BookPost!
  cursor: String!
}

enum BookPostOrderByInput {
  id_ASC
  id_DESC
  bookName_ASC
  bookName_DESC
  bookPublisher_ASC
  bookPublisher_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BookPostPreviousValues {
  id: ID!
  bookName: String!
  bookPublisher: String!
  LinkedStore: [LinkedStore!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BookPostSubscriptionPayload {
  mutation: MutationType!
  node: BookPost
  updatedFields: [String!]
  previousValues: BookPostPreviousValues
}

input BookPostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BookPostWhereInput
  AND: [BookPostSubscriptionWhereInput!]
  OR: [BookPostSubscriptionWhereInput!]
  NOT: [BookPostSubscriptionWhereInput!]
}

input BookPostUpdateInput {
  post: PostUpdateOneRequiredWithoutBookPostsInput
  bookName: String
  bookPublisher: String
  LinkedStore: BookPostUpdateLinkedStoreInput
}

input BookPostUpdateLinkedStoreInput {
  set: [LinkedStore!]
}

input BookPostUpdateManyMutationInput {
  bookName: String
  bookPublisher: String
  LinkedStore: BookPostUpdateLinkedStoreInput
}

input BookPostUpdateOneRequiredWithoutPostInput {
  create: BookPostCreateWithoutPostInput
  update: BookPostUpdateWithoutPostDataInput
  upsert: BookPostUpsertWithoutPostInput
  connect: BookPostWhereUniqueInput
}

input BookPostUpdateWithoutPostDataInput {
  bookName: String
  bookPublisher: String
  LinkedStore: BookPostUpdateLinkedStoreInput
}

input BookPostUpsertWithoutPostInput {
  update: BookPostUpdateWithoutPostDataInput!
  create: BookPostCreateWithoutPostInput!
}

input BookPostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  post: PostWhereInput
  bookName: String
  bookName_not: String
  bookName_in: [String!]
  bookName_not_in: [String!]
  bookName_lt: String
  bookName_lte: String
  bookName_gt: String
  bookName_gte: String
  bookName_contains: String
  bookName_not_contains: String
  bookName_starts_with: String
  bookName_not_starts_with: String
  bookName_ends_with: String
  bookName_not_ends_with: String
  bookPublisher: String
  bookPublisher_not: String
  bookPublisher_in: [String!]
  bookPublisher_not_in: [String!]
  bookPublisher_lt: String
  bookPublisher_lte: String
  bookPublisher_gt: String
  bookPublisher_gte: String
  bookPublisher_contains: String
  bookPublisher_not_contains: String
  bookPublisher_starts_with: String
  bookPublisher_not_starts_with: String
  bookPublisher_ends_with: String
  bookPublisher_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BookPostWhereInput!]
  OR: [BookPostWhereInput!]
  NOT: [BookPostWhereInput!]
}

input BookPostWhereUniqueInput {
  id: ID
}

enum Category {
  GENERAL
  GIT
  BOOK
}

type Comment {
  id: ID!
  post: Post!
  author: User!
  contents: String!
  replies(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likes: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  post: PostCreateOneWithoutCommentsInput!
  author: UserCreateOneWithoutCommentsInput!
  contents: String!
  replies: CommentCreateManyWithoutRepliesInput
  likes: Int
}

input CommentCreateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutRepliesInput {
  create: [CommentCreateWithoutRepliesInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAuthorInput {
  id: ID
  post: PostCreateOneWithoutCommentsInput!
  contents: String!
  replies: CommentCreateManyWithoutRepliesInput
  likes: Int
}

input CommentCreateWithoutPostInput {
  id: ID
  author: UserCreateOneWithoutCommentsInput!
  contents: String!
  replies: CommentCreateManyWithoutRepliesInput
  likes: Int
}

input CommentCreateWithoutRepliesInput {
  id: ID
  post: PostCreateOneWithoutCommentsInput!
  author: UserCreateOneWithoutCommentsInput!
  contents: String!
  likes: Int
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  contents_ASC
  contents_DESC
  likes_ASC
  likes_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentPreviousValues {
  id: ID!
  contents: String!
  likes: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  contents: String
  contents_not: String
  contents_in: [String!]
  contents_not_in: [String!]
  contents_lt: String
  contents_lte: String
  contents_gt: String
  contents_gte: String
  contents_contains: String
  contents_not_contains: String
  contents_starts_with: String
  contents_not_starts_with: String
  contents_ends_with: String
  contents_not_ends_with: String
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
  author: UserUpdateOneRequiredWithoutCommentsInput
  contents: String
  replies: CommentUpdateManyWithoutRepliesInput
  likes: Int
}

input CommentUpdateManyDataInput {
  contents: String
  likes: Int
}

input CommentUpdateManyMutationInput {
  contents: String
  likes: Int
}

input CommentUpdateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutRepliesInput {
  create: [CommentCreateWithoutRepliesInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutRepliesInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutRepliesInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutAuthorDataInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
  contents: String
  replies: CommentUpdateManyWithoutRepliesInput
  likes: Int
}

input CommentUpdateWithoutPostDataInput {
  author: UserUpdateOneRequiredWithoutCommentsInput
  contents: String
  replies: CommentUpdateManyWithoutRepliesInput
  likes: Int
}

input CommentUpdateWithoutRepliesDataInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
  author: UserUpdateOneRequiredWithoutCommentsInput
  contents: String
  likes: Int
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAuthorDataInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpdateWithWhereUniqueWithoutRepliesInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutRepliesDataInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAuthorDataInput!
  create: CommentCreateWithoutAuthorInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentUpsertWithWhereUniqueWithoutRepliesInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutRepliesDataInput!
  create: CommentCreateWithoutRepliesInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  post: PostWhereInput
  author: UserWhereInput
  contents: String
  contents_not: String
  contents_in: [String!]
  contents_not_in: [String!]
  contents_lt: String
  contents_lte: String
  contents_gt: String
  contents_gte: String
  contents_contains: String
  contents_not_contains: String
  contents_starts_with: String
  contents_not_starts_with: String
  contents_ends_with: String
  contents_not_ends_with: String
  replies_every: CommentWhereInput
  replies_some: CommentWhereInput
  replies_none: CommentWhereInput
  likes: Int
  likes_not: Int
  likes_in: [Int!]
  likes_not_in: [Int!]
  likes_lt: Int
  likes_lte: Int
  likes_gt: Int
  likes_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

type Contributor {
  id: ID!
  user: User!
  type: [ContributorType!]!
  contributedAt: DateTime!
  correctionRange: String
}

type ContributorConnection {
  pageInfo: PageInfo!
  edges: [ContributorEdge]!
  aggregate: AggregateContributor!
}

input ContributorCreateInput {
  id: ID
  user: UserCreateOneInput!
  type: ContributorCreatetypeInput
  contributedAt: DateTime!
  correctionRange: String
}

input ContributorCreatetypeInput {
  set: [ContributorType!]
}

type ContributorEdge {
  node: Contributor!
  cursor: String!
}

enum ContributorOrderByInput {
  id_ASC
  id_DESC
  contributedAt_ASC
  contributedAt_DESC
  correctionRange_ASC
  correctionRange_DESC
}

type ContributorPreviousValues {
  id: ID!
  type: [ContributorType!]!
  contributedAt: DateTime!
  correctionRange: String
}

type ContributorSubscriptionPayload {
  mutation: MutationType!
  node: Contributor
  updatedFields: [String!]
  previousValues: ContributorPreviousValues
}

input ContributorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContributorWhereInput
  AND: [ContributorSubscriptionWhereInput!]
  OR: [ContributorSubscriptionWhereInput!]
  NOT: [ContributorSubscriptionWhereInput!]
}

enum ContributorType {
  TYPO
  INFO_CORRECTION
  INFO_ADDTION
}

input ContributorUpdateInput {
  user: UserUpdateOneRequiredInput
  type: ContributorUpdatetypeInput
  contributedAt: DateTime
  correctionRange: String
}

input ContributorUpdateManyMutationInput {
  type: ContributorUpdatetypeInput
  contributedAt: DateTime
  correctionRange: String
}

input ContributorUpdatetypeInput {
  set: [ContributorType!]
}

input ContributorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  contributedAt: DateTime
  contributedAt_not: DateTime
  contributedAt_in: [DateTime!]
  contributedAt_not_in: [DateTime!]
  contributedAt_lt: DateTime
  contributedAt_lte: DateTime
  contributedAt_gt: DateTime
  contributedAt_gte: DateTime
  correctionRange: String
  correctionRange_not: String
  correctionRange_in: [String!]
  correctionRange_not_in: [String!]
  correctionRange_lt: String
  correctionRange_lte: String
  correctionRange_gt: String
  correctionRange_gte: String
  correctionRange_contains: String
  correctionRange_not_contains: String
  correctionRange_starts_with: String
  correctionRange_not_starts_with: String
  correctionRange_ends_with: String
  correctionRange_not_ends_with: String
  AND: [ContributorWhereInput!]
  OR: [ContributorWhereInput!]
  NOT: [ContributorWhereInput!]
}

input ContributorWhereUniqueInput {
  id: ID
}

scalar DateTime

type Event {
  id: ID!
  name: String!
  topic: Topic!
  description: String!
  mainImg: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  id: ID
  name: String!
  topic: TopicCreateOneWithoutEventsInput!
  description: String!
  mainImg: String
}

input EventCreateManyWithoutTopicInput {
  create: [EventCreateWithoutTopicInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateWithoutTopicInput {
  id: ID
  name: String!
  description: String!
  mainImg: String
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  mainImg_ASC
  mainImg_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EventPreviousValues {
  id: ID!
  name: String!
  description: String!
  mainImg: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input EventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  mainImg: String
  mainImg_not: String
  mainImg_in: [String!]
  mainImg_not_in: [String!]
  mainImg_lt: String
  mainImg_lte: String
  mainImg_gt: String
  mainImg_gte: String
  mainImg_contains: String
  mainImg_not_contains: String
  mainImg_starts_with: String
  mainImg_not_starts_with: String
  mainImg_ends_with: String
  mainImg_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

input EventUpdateInput {
  name: String
  topic: TopicUpdateOneRequiredWithoutEventsInput
  description: String
  mainImg: String
}

input EventUpdateManyDataInput {
  name: String
  description: String
  mainImg: String
}

input EventUpdateManyMutationInput {
  name: String
  description: String
  mainImg: String
}

input EventUpdateManyWithoutTopicInput {
  create: [EventCreateWithoutTopicInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutTopicInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutTopicInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput!
  data: EventUpdateManyDataInput!
}

input EventUpdateWithoutTopicDataInput {
  name: String
  description: String
  mainImg: String
}

input EventUpdateWithWhereUniqueWithoutTopicInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutTopicDataInput!
}

input EventUpsertWithWhereUniqueWithoutTopicInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutTopicDataInput!
  create: EventCreateWithoutTopicInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  topic: TopicWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  mainImg: String
  mainImg_not: String
  mainImg_in: [String!]
  mainImg_not_in: [String!]
  mainImg_lt: String
  mainImg_lte: String
  mainImg_gt: String
  mainImg_gte: String
  mainImg_contains: String
  mainImg_not_contains: String
  mainImg_starts_with: String
  mainImg_not_starts_with: String
  mainImg_ends_with: String
  mainImg_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type File {
  id: ID!
  author: User!
  alias: String!
  type: [FileType!]!
  size: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: ID
  author: UserCreateOneInput!
  alias: String!
  type: FileCreatetypeInput
  size: String!
}

input FileCreatetypeInput {
  set: [FileType!]
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  alias_ASC
  alias_DESC
  size_ASC
  size_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FilePreviousValues {
  id: ID!
  alias: String!
  type: [FileType!]!
  size: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

enum FileType {
  IMAGE
  PDF
  ETC
}

input FileUpdateInput {
  author: UserUpdateOneRequiredInput
  alias: String
  type: FileUpdatetypeInput
  size: String
}

input FileUpdateManyMutationInput {
  alias: String
  type: FileUpdatetypeInput
  size: String
}

input FileUpdatetypeInput {
  set: [FileType!]
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: UserWhereInput
  alias: String
  alias_not: String
  alias_in: [String!]
  alias_not_in: [String!]
  alias_lt: String
  alias_lte: String
  alias_gt: String
  alias_gte: String
  alias_contains: String
  alias_not_contains: String
  alias_starts_with: String
  alias_not_starts_with: String
  alias_ends_with: String
  alias_not_ends_with: String
  size: String
  size_not: String
  size_in: [String!]
  size_not_in: [String!]
  size_lt: String
  size_lte: String
  size_gt: String
  size_gte: String
  size_contains: String
  size_not_contains: String
  size_starts_with: String
  size_not_starts_with: String
  size_ends_with: String
  size_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
}

type GitPost {
  id: ID!
  post: Post!
  gitId: String!
  gitAuthor: [String!]!
  gitTitle: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GitPostConnection {
  pageInfo: PageInfo!
  edges: [GitPostEdge]!
  aggregate: AggregateGitPost!
}

input GitPostCreategitAuthorInput {
  set: [String!]
}

input GitPostCreateInput {
  id: ID
  post: PostCreateOneWithoutGitPostsInput!
  gitId: String!
  gitAuthor: GitPostCreategitAuthorInput
  gitTitle: String!
}

input GitPostCreateOneWithoutPostInput {
  create: GitPostCreateWithoutPostInput
  connect: GitPostWhereUniqueInput
}

input GitPostCreateWithoutPostInput {
  id: ID
  gitId: String!
  gitAuthor: GitPostCreategitAuthorInput
  gitTitle: String!
}

type GitPostEdge {
  node: GitPost!
  cursor: String!
}

enum GitPostOrderByInput {
  id_ASC
  id_DESC
  gitId_ASC
  gitId_DESC
  gitTitle_ASC
  gitTitle_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GitPostPreviousValues {
  id: ID!
  gitId: String!
  gitAuthor: [String!]!
  gitTitle: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GitPostSubscriptionPayload {
  mutation: MutationType!
  node: GitPost
  updatedFields: [String!]
  previousValues: GitPostPreviousValues
}

input GitPostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GitPostWhereInput
  AND: [GitPostSubscriptionWhereInput!]
  OR: [GitPostSubscriptionWhereInput!]
  NOT: [GitPostSubscriptionWhereInput!]
}

input GitPostUpdategitAuthorInput {
  set: [String!]
}

input GitPostUpdateInput {
  post: PostUpdateOneRequiredWithoutGitPostsInput
  gitId: String
  gitAuthor: GitPostUpdategitAuthorInput
  gitTitle: String
}

input GitPostUpdateManyMutationInput {
  gitId: String
  gitAuthor: GitPostUpdategitAuthorInput
  gitTitle: String
}

input GitPostUpdateOneRequiredWithoutPostInput {
  create: GitPostCreateWithoutPostInput
  update: GitPostUpdateWithoutPostDataInput
  upsert: GitPostUpsertWithoutPostInput
  connect: GitPostWhereUniqueInput
}

input GitPostUpdateWithoutPostDataInput {
  gitId: String
  gitAuthor: GitPostUpdategitAuthorInput
  gitTitle: String
}

input GitPostUpsertWithoutPostInput {
  update: GitPostUpdateWithoutPostDataInput!
  create: GitPostCreateWithoutPostInput!
}

input GitPostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  post: PostWhereInput
  gitId: String
  gitId_not: String
  gitId_in: [String!]
  gitId_not_in: [String!]
  gitId_lt: String
  gitId_lte: String
  gitId_gt: String
  gitId_gte: String
  gitId_contains: String
  gitId_not_contains: String
  gitId_starts_with: String
  gitId_not_starts_with: String
  gitId_ends_with: String
  gitId_not_ends_with: String
  gitTitle: String
  gitTitle_not: String
  gitTitle_in: [String!]
  gitTitle_not_in: [String!]
  gitTitle_lt: String
  gitTitle_lte: String
  gitTitle_gt: String
  gitTitle_gte: String
  gitTitle_contains: String
  gitTitle_not_contains: String
  gitTitle_starts_with: String
  gitTitle_not_starts_with: String
  gitTitle_ends_with: String
  gitTitle_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GitPostWhereInput!]
  OR: [GitPostWhereInput!]
  NOT: [GitPostWhereInput!]
}

input GitPostWhereUniqueInput {
  id: ID
}

enum levelType {
  VISITOR
  MEMBER
  WRITER
  MANAGER
}

enum LinkedStore {
  YES24
  KYOBO
}

scalar Long

type Mutation {
  createBookPost(data: BookPostCreateInput!): BookPost!
  updateBookPost(data: BookPostUpdateInput!, where: BookPostWhereUniqueInput!): BookPost
  updateManyBookPosts(data: BookPostUpdateManyMutationInput!, where: BookPostWhereInput): BatchPayload!
  upsertBookPost(where: BookPostWhereUniqueInput!, create: BookPostCreateInput!, update: BookPostUpdateInput!): BookPost!
  deleteBookPost(where: BookPostWhereUniqueInput!): BookPost
  deleteManyBookPosts(where: BookPostWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createContributor(data: ContributorCreateInput!): Contributor!
  updateContributor(data: ContributorUpdateInput!, where: ContributorWhereUniqueInput!): Contributor
  updateManyContributors(data: ContributorUpdateManyMutationInput!, where: ContributorWhereInput): BatchPayload!
  upsertContributor(where: ContributorWhereUniqueInput!, create: ContributorCreateInput!, update: ContributorUpdateInput!): Contributor!
  deleteContributor(where: ContributorWhereUniqueInput!): Contributor
  deleteManyContributors(where: ContributorWhereInput): BatchPayload!
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createGitPost(data: GitPostCreateInput!): GitPost!
  updateGitPost(data: GitPostUpdateInput!, where: GitPostWhereUniqueInput!): GitPost
  updateManyGitPosts(data: GitPostUpdateManyMutationInput!, where: GitPostWhereInput): BatchPayload!
  upsertGitPost(where: GitPostWhereUniqueInput!, create: GitPostCreateInput!, update: GitPostUpdateInput!): GitPost!
  deleteGitPost(where: GitPostWhereUniqueInput!): GitPost
  deleteManyGitPosts(where: GitPostWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createSeries(data: SeriesCreateInput!): Series!
  updateSeries(data: SeriesUpdateInput!, where: SeriesWhereUniqueInput!): Series
  updateManySerieses(data: SeriesUpdateManyMutationInput!, where: SeriesWhereInput): BatchPayload!
  upsertSeries(where: SeriesWhereUniqueInput!, create: SeriesCreateInput!, update: SeriesUpdateInput!): Series!
  deleteSeries(where: SeriesWhereUniqueInput!): Series
  deleteManySerieses(where: SeriesWhereInput): BatchPayload!
  createTopic(data: TopicCreateInput!): Topic!
  updateTopic(data: TopicUpdateInput!, where: TopicWhereUniqueInput!): Topic
  updateManyTopics(data: TopicUpdateManyMutationInput!, where: TopicWhereInput): BatchPayload!
  upsertTopic(where: TopicWhereUniqueInput!, create: TopicCreateInput!, update: TopicUpdateInput!): Topic!
  deleteTopic(where: TopicWhereUniqueInput!): Topic
  deleteManyTopics(where: TopicWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Post {
  id: ID!
  category: Category!
  coverImg: String
  owner: User!
  topics(where: TopicWhereInput, orderBy: TopicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Topic!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  gitPosts: GitPost!
  bookPosts: BookPost!
  series: Series
  contents: String!
  keywords: [String!]!
  summary: [String!]!
  numViews: Int!
  numLikes: Int!
  numComments: Int!
  isPrivate: Boolean!
  publishedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  category: Category
  coverImg: String
  owner: UserCreateOneWithoutPostsInput!
  topics: TopicCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  gitPosts: GitPostCreateOneWithoutPostInput!
  bookPosts: BookPostCreateOneWithoutPostInput!
  series: SeriesCreateOneWithoutPostsInput
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostCreatekeywordsInput {
  set: [String!]
}

input PostCreateManyWithoutOwnerInput {
  create: [PostCreateWithoutOwnerInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateManyWithoutSeriesInput {
  create: [PostCreateWithoutSeriesInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateManyWithoutTopicsInput {
  create: [PostCreateWithoutTopicsInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutBookPostsInput {
  create: PostCreateWithoutBookPostsInput
  connect: PostWhereUniqueInput
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateOneWithoutGitPostsInput {
  create: PostCreateWithoutGitPostsInput
  connect: PostWhereUniqueInput
}

input PostCreatesummaryInput {
  set: [String!]
}

input PostCreateWithoutBookPostsInput {
  id: ID
  category: Category
  coverImg: String
  owner: UserCreateOneWithoutPostsInput!
  topics: TopicCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  gitPosts: GitPostCreateOneWithoutPostInput!
  series: SeriesCreateOneWithoutPostsInput
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostCreateWithoutCommentsInput {
  id: ID
  category: Category
  coverImg: String
  owner: UserCreateOneWithoutPostsInput!
  topics: TopicCreateManyWithoutPostsInput
  gitPosts: GitPostCreateOneWithoutPostInput!
  bookPosts: BookPostCreateOneWithoutPostInput!
  series: SeriesCreateOneWithoutPostsInput
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostCreateWithoutGitPostsInput {
  id: ID
  category: Category
  coverImg: String
  owner: UserCreateOneWithoutPostsInput!
  topics: TopicCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  bookPosts: BookPostCreateOneWithoutPostInput!
  series: SeriesCreateOneWithoutPostsInput
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostCreateWithoutOwnerInput {
  id: ID
  category: Category
  coverImg: String
  topics: TopicCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  gitPosts: GitPostCreateOneWithoutPostInput!
  bookPosts: BookPostCreateOneWithoutPostInput!
  series: SeriesCreateOneWithoutPostsInput
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostCreateWithoutSeriesInput {
  id: ID
  category: Category
  coverImg: String
  owner: UserCreateOneWithoutPostsInput!
  topics: TopicCreateManyWithoutPostsInput
  comments: CommentCreateManyWithoutPostInput
  gitPosts: GitPostCreateOneWithoutPostInput!
  bookPosts: BookPostCreateOneWithoutPostInput!
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostCreateWithoutTopicsInput {
  id: ID
  category: Category
  coverImg: String
  owner: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostInput
  gitPosts: GitPostCreateOneWithoutPostInput!
  bookPosts: BookPostCreateOneWithoutPostInput!
  series: SeriesCreateOneWithoutPostsInput
  contents: String!
  keywords: PostCreatekeywordsInput
  summary: PostCreatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  category_ASC
  category_DESC
  coverImg_ASC
  coverImg_DESC
  contents_ASC
  contents_DESC
  numViews_ASC
  numViews_DESC
  numLikes_ASC
  numLikes_DESC
  numComments_ASC
  numComments_DESC
  isPrivate_ASC
  isPrivate_DESC
  publishedAt_ASC
  publishedAt_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostPreviousValues {
  id: ID!
  category: Category!
  coverImg: String
  contents: String!
  keywords: [String!]!
  summary: [String!]!
  numViews: Int!
  numLikes: Int!
  numComments: Int!
  isPrivate: Boolean!
  publishedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  coverImg: String
  coverImg_not: String
  coverImg_in: [String!]
  coverImg_not_in: [String!]
  coverImg_lt: String
  coverImg_lte: String
  coverImg_gt: String
  coverImg_gte: String
  coverImg_contains: String
  coverImg_not_contains: String
  coverImg_starts_with: String
  coverImg_not_starts_with: String
  coverImg_ends_with: String
  coverImg_not_ends_with: String
  contents: String
  contents_not: String
  contents_in: [String!]
  contents_not_in: [String!]
  contents_lt: String
  contents_lte: String
  contents_gt: String
  contents_gte: String
  contents_contains: String
  contents_not_contains: String
  contents_starts_with: String
  contents_not_starts_with: String
  contents_ends_with: String
  contents_not_ends_with: String
  numViews: Int
  numViews_not: Int
  numViews_in: [Int!]
  numViews_not_in: [Int!]
  numViews_lt: Int
  numViews_lte: Int
  numViews_gt: Int
  numViews_gte: Int
  numLikes: Int
  numLikes_not: Int
  numLikes_in: [Int!]
  numLikes_not_in: [Int!]
  numLikes_lt: Int
  numLikes_lte: Int
  numLikes_gt: Int
  numLikes_gte: Int
  numComments: Int
  numComments_not: Int
  numComments_in: [Int!]
  numComments_not_in: [Int!]
  numComments_lt: Int
  numComments_lte: Int
  numComments_gt: Int
  numComments_gte: Int
  isPrivate: Boolean
  isPrivate_not: Boolean
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  category: Category
  coverImg: String
  owner: UserUpdateOneRequiredWithoutPostsInput
  topics: TopicUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  gitPosts: GitPostUpdateOneRequiredWithoutPostInput
  bookPosts: BookPostUpdateOneRequiredWithoutPostInput
  series: SeriesUpdateOneWithoutPostsInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdatekeywordsInput {
  set: [String!]
}

input PostUpdateManyDataInput {
  category: Category
  coverImg: String
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateManyMutationInput {
  category: Category
  coverImg: String
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateManyWithoutOwnerInput {
  create: [PostCreateWithoutOwnerInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithoutSeriesInput {
  create: [PostCreateWithoutSeriesInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutSeriesInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutSeriesInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithoutTopicsInput {
  create: [PostCreateWithoutTopicsInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutTopicsInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutTopicsInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneRequiredWithoutBookPostsInput {
  create: PostCreateWithoutBookPostsInput
  update: PostUpdateWithoutBookPostsDataInput
  upsert: PostUpsertWithoutBookPostsInput
  connect: PostWhereUniqueInput
}

input PostUpdateOneRequiredWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostUpdateOneRequiredWithoutGitPostsInput {
  create: PostCreateWithoutGitPostsInput
  update: PostUpdateWithoutGitPostsDataInput
  upsert: PostUpsertWithoutGitPostsInput
  connect: PostWhereUniqueInput
}

input PostUpdatesummaryInput {
  set: [String!]
}

input PostUpdateWithoutBookPostsDataInput {
  category: Category
  coverImg: String
  owner: UserUpdateOneRequiredWithoutPostsInput
  topics: TopicUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  gitPosts: GitPostUpdateOneRequiredWithoutPostInput
  series: SeriesUpdateOneWithoutPostsInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateWithoutCommentsDataInput {
  category: Category
  coverImg: String
  owner: UserUpdateOneRequiredWithoutPostsInput
  topics: TopicUpdateManyWithoutPostsInput
  gitPosts: GitPostUpdateOneRequiredWithoutPostInput
  bookPosts: BookPostUpdateOneRequiredWithoutPostInput
  series: SeriesUpdateOneWithoutPostsInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateWithoutGitPostsDataInput {
  category: Category
  coverImg: String
  owner: UserUpdateOneRequiredWithoutPostsInput
  topics: TopicUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  bookPosts: BookPostUpdateOneRequiredWithoutPostInput
  series: SeriesUpdateOneWithoutPostsInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateWithoutOwnerDataInput {
  category: Category
  coverImg: String
  topics: TopicUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  gitPosts: GitPostUpdateOneRequiredWithoutPostInput
  bookPosts: BookPostUpdateOneRequiredWithoutPostInput
  series: SeriesUpdateOneWithoutPostsInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateWithoutSeriesDataInput {
  category: Category
  coverImg: String
  owner: UserUpdateOneRequiredWithoutPostsInput
  topics: TopicUpdateManyWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  gitPosts: GitPostUpdateOneRequiredWithoutPostInput
  bookPosts: BookPostUpdateOneRequiredWithoutPostInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateWithoutTopicsDataInput {
  category: Category
  coverImg: String
  owner: UserUpdateOneRequiredWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  gitPosts: GitPostUpdateOneRequiredWithoutPostInput
  bookPosts: BookPostUpdateOneRequiredWithoutPostInput
  series: SeriesUpdateOneWithoutPostsInput
  contents: String
  keywords: PostUpdatekeywordsInput
  summary: PostUpdatesummaryInput
  numViews: Int
  numLikes: Int
  numComments: Int
  isPrivate: Boolean
  publishedAt: DateTime
}

input PostUpdateWithWhereUniqueWithoutOwnerInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutOwnerDataInput!
}

input PostUpdateWithWhereUniqueWithoutSeriesInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutSeriesDataInput!
}

input PostUpdateWithWhereUniqueWithoutTopicsInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutTopicsDataInput!
}

input PostUpsertWithoutBookPostsInput {
  update: PostUpdateWithoutBookPostsDataInput!
  create: PostCreateWithoutBookPostsInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithoutGitPostsInput {
  update: PostUpdateWithoutGitPostsDataInput!
  create: PostCreateWithoutGitPostsInput!
}

input PostUpsertWithWhereUniqueWithoutOwnerInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutOwnerDataInput!
  create: PostCreateWithoutOwnerInput!
}

input PostUpsertWithWhereUniqueWithoutSeriesInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutSeriesDataInput!
  create: PostCreateWithoutSeriesInput!
}

input PostUpsertWithWhereUniqueWithoutTopicsInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutTopicsDataInput!
  create: PostCreateWithoutTopicsInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  coverImg: String
  coverImg_not: String
  coverImg_in: [String!]
  coverImg_not_in: [String!]
  coverImg_lt: String
  coverImg_lte: String
  coverImg_gt: String
  coverImg_gte: String
  coverImg_contains: String
  coverImg_not_contains: String
  coverImg_starts_with: String
  coverImg_not_starts_with: String
  coverImg_ends_with: String
  coverImg_not_ends_with: String
  owner: UserWhereInput
  topics_every: TopicWhereInput
  topics_some: TopicWhereInput
  topics_none: TopicWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  gitPosts: GitPostWhereInput
  bookPosts: BookPostWhereInput
  series: SeriesWhereInput
  contents: String
  contents_not: String
  contents_in: [String!]
  contents_not_in: [String!]
  contents_lt: String
  contents_lte: String
  contents_gt: String
  contents_gte: String
  contents_contains: String
  contents_not_contains: String
  contents_starts_with: String
  contents_not_starts_with: String
  contents_ends_with: String
  contents_not_ends_with: String
  numViews: Int
  numViews_not: Int
  numViews_in: [Int!]
  numViews_not_in: [Int!]
  numViews_lt: Int
  numViews_lte: Int
  numViews_gt: Int
  numViews_gte: Int
  numLikes: Int
  numLikes_not: Int
  numLikes_in: [Int!]
  numLikes_not_in: [Int!]
  numLikes_lt: Int
  numLikes_lte: Int
  numLikes_gt: Int
  numLikes_gte: Int
  numComments: Int
  numComments_not: Int
  numComments_in: [Int!]
  numComments_not_in: [Int!]
  numComments_lt: Int
  numComments_lte: Int
  numComments_gt: Int
  numComments_gte: Int
  isPrivate: Boolean
  isPrivate_not: Boolean
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  bookPost(where: BookPostWhereUniqueInput!): BookPost
  bookPosts(where: BookPostWhereInput, orderBy: BookPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BookPost]!
  bookPostsConnection(where: BookPostWhereInput, orderBy: BookPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BookPostConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  contributor(where: ContributorWhereUniqueInput!): Contributor
  contributors(where: ContributorWhereInput, orderBy: ContributorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contributor]!
  contributorsConnection(where: ContributorWhereInput, orderBy: ContributorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContributorConnection!
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  gitPost(where: GitPostWhereUniqueInput!): GitPost
  gitPosts(where: GitPostWhereInput, orderBy: GitPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [GitPost]!
  gitPostsConnection(where: GitPostWhereInput, orderBy: GitPostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GitPostConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  series(where: SeriesWhereUniqueInput!): Series
  serieses(where: SeriesWhereInput, orderBy: SeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Series]!
  seriesesConnection(where: SeriesWhereInput, orderBy: SeriesOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeriesConnection!
  topic(where: TopicWhereUniqueInput!): Topic
  topics(where: TopicWhereInput, orderBy: TopicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Topic]!
  topicsConnection(where: TopicWhereInput, orderBy: TopicOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TopicConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Series {
  id: ID!
  name: String!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  description: String!
  numViews: Int!
  numLikes: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeriesConnection {
  pageInfo: PageInfo!
  edges: [SeriesEdge]!
  aggregate: AggregateSeries!
}

input SeriesCreateInput {
  id: ID
  name: String!
  posts: PostCreateManyWithoutSeriesInput
  description: String!
  numViews: Int
  numLikes: Int
}

input SeriesCreateOneWithoutPostsInput {
  create: SeriesCreateWithoutPostsInput
  connect: SeriesWhereUniqueInput
}

input SeriesCreateWithoutPostsInput {
  id: ID
  name: String!
  description: String!
  numViews: Int
  numLikes: Int
}

type SeriesEdge {
  node: Series!
  cursor: String!
}

enum SeriesOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  numViews_ASC
  numViews_DESC
  numLikes_ASC
  numLikes_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SeriesPreviousValues {
  id: ID!
  name: String!
  description: String!
  numViews: Int!
  numLikes: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeriesSubscriptionPayload {
  mutation: MutationType!
  node: Series
  updatedFields: [String!]
  previousValues: SeriesPreviousValues
}

input SeriesSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeriesWhereInput
  AND: [SeriesSubscriptionWhereInput!]
  OR: [SeriesSubscriptionWhereInput!]
  NOT: [SeriesSubscriptionWhereInput!]
}

input SeriesUpdateInput {
  name: String
  posts: PostUpdateManyWithoutSeriesInput
  description: String
  numViews: Int
  numLikes: Int
}

input SeriesUpdateManyMutationInput {
  name: String
  description: String
  numViews: Int
  numLikes: Int
}

input SeriesUpdateOneWithoutPostsInput {
  create: SeriesCreateWithoutPostsInput
  update: SeriesUpdateWithoutPostsDataInput
  upsert: SeriesUpsertWithoutPostsInput
  delete: Boolean
  disconnect: Boolean
  connect: SeriesWhereUniqueInput
}

input SeriesUpdateWithoutPostsDataInput {
  name: String
  description: String
  numViews: Int
  numLikes: Int
}

input SeriesUpsertWithoutPostsInput {
  update: SeriesUpdateWithoutPostsDataInput!
  create: SeriesCreateWithoutPostsInput!
}

input SeriesWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  numViews: Int
  numViews_not: Int
  numViews_in: [Int!]
  numViews_not_in: [Int!]
  numViews_lt: Int
  numViews_lte: Int
  numViews_gt: Int
  numViews_gte: Int
  numLikes: Int
  numLikes_not: Int
  numLikes_in: [Int!]
  numLikes_not_in: [Int!]
  numLikes_lt: Int
  numLikes_lte: Int
  numLikes_gt: Int
  numLikes_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SeriesWhereInput!]
  OR: [SeriesWhereInput!]
  NOT: [SeriesWhereInput!]
}

input SeriesWhereUniqueInput {
  id: ID
}

type Subscription {
  bookPost(where: BookPostSubscriptionWhereInput): BookPostSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  contributor(where: ContributorSubscriptionWhereInput): ContributorSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  gitPost(where: GitPostSubscriptionWhereInput): GitPostSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  series(where: SeriesSubscriptionWhereInput): SeriesSubscriptionPayload
  topic(where: TopicSubscriptionWhereInput): TopicSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Topic {
  id: ID!
  name: String!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  coverImg: String
  coverDescription: String
  numViews: Int!
  backImg: String
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TopicConnection {
  pageInfo: PageInfo!
  edges: [TopicEdge]!
  aggregate: AggregateTopic!
}

input TopicCreateInput {
  id: ID
  name: String!
  posts: PostCreateManyWithoutTopicsInput
  events: EventCreateManyWithoutTopicInput
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicCreateManyWithoutPostsInput {
  create: [TopicCreateWithoutPostsInput!]
  connect: [TopicWhereUniqueInput!]
}

input TopicCreateOneWithoutEventsInput {
  create: TopicCreateWithoutEventsInput
  connect: TopicWhereUniqueInput
}

input TopicCreateWithoutEventsInput {
  id: ID
  name: String!
  posts: PostCreateManyWithoutTopicsInput
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicCreateWithoutPostsInput {
  id: ID
  name: String!
  events: EventCreateManyWithoutTopicInput
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

type TopicEdge {
  node: Topic!
  cursor: String!
}

enum TopicOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  coverImg_ASC
  coverImg_DESC
  coverDescription_ASC
  coverDescription_DESC
  numViews_ASC
  numViews_DESC
  backImg_ASC
  backImg_DESC
  icon_ASC
  icon_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TopicPreviousValues {
  id: ID!
  name: String!
  coverImg: String
  coverDescription: String
  numViews: Int!
  backImg: String
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

input TopicScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  coverImg: String
  coverImg_not: String
  coverImg_in: [String!]
  coverImg_not_in: [String!]
  coverImg_lt: String
  coverImg_lte: String
  coverImg_gt: String
  coverImg_gte: String
  coverImg_contains: String
  coverImg_not_contains: String
  coverImg_starts_with: String
  coverImg_not_starts_with: String
  coverImg_ends_with: String
  coverImg_not_ends_with: String
  coverDescription: String
  coverDescription_not: String
  coverDescription_in: [String!]
  coverDescription_not_in: [String!]
  coverDescription_lt: String
  coverDescription_lte: String
  coverDescription_gt: String
  coverDescription_gte: String
  coverDescription_contains: String
  coverDescription_not_contains: String
  coverDescription_starts_with: String
  coverDescription_not_starts_with: String
  coverDescription_ends_with: String
  coverDescription_not_ends_with: String
  numViews: Int
  numViews_not: Int
  numViews_in: [Int!]
  numViews_not_in: [Int!]
  numViews_lt: Int
  numViews_lte: Int
  numViews_gt: Int
  numViews_gte: Int
  backImg: String
  backImg_not: String
  backImg_in: [String!]
  backImg_not_in: [String!]
  backImg_lt: String
  backImg_lte: String
  backImg_gt: String
  backImg_gte: String
  backImg_contains: String
  backImg_not_contains: String
  backImg_starts_with: String
  backImg_not_starts_with: String
  backImg_ends_with: String
  backImg_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TopicScalarWhereInput!]
  OR: [TopicScalarWhereInput!]
  NOT: [TopicScalarWhereInput!]
}

type TopicSubscriptionPayload {
  mutation: MutationType!
  node: Topic
  updatedFields: [String!]
  previousValues: TopicPreviousValues
}

input TopicSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TopicWhereInput
  AND: [TopicSubscriptionWhereInput!]
  OR: [TopicSubscriptionWhereInput!]
  NOT: [TopicSubscriptionWhereInput!]
}

input TopicUpdateInput {
  name: String
  posts: PostUpdateManyWithoutTopicsInput
  events: EventUpdateManyWithoutTopicInput
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicUpdateManyDataInput {
  name: String
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicUpdateManyMutationInput {
  name: String
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicUpdateManyWithoutPostsInput {
  create: [TopicCreateWithoutPostsInput!]
  delete: [TopicWhereUniqueInput!]
  connect: [TopicWhereUniqueInput!]
  set: [TopicWhereUniqueInput!]
  disconnect: [TopicWhereUniqueInput!]
  update: [TopicUpdateWithWhereUniqueWithoutPostsInput!]
  upsert: [TopicUpsertWithWhereUniqueWithoutPostsInput!]
  deleteMany: [TopicScalarWhereInput!]
  updateMany: [TopicUpdateManyWithWhereNestedInput!]
}

input TopicUpdateManyWithWhereNestedInput {
  where: TopicScalarWhereInput!
  data: TopicUpdateManyDataInput!
}

input TopicUpdateOneRequiredWithoutEventsInput {
  create: TopicCreateWithoutEventsInput
  update: TopicUpdateWithoutEventsDataInput
  upsert: TopicUpsertWithoutEventsInput
  connect: TopicWhereUniqueInput
}

input TopicUpdateWithoutEventsDataInput {
  name: String
  posts: PostUpdateManyWithoutTopicsInput
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicUpdateWithoutPostsDataInput {
  name: String
  events: EventUpdateManyWithoutTopicInput
  coverImg: String
  coverDescription: String
  numViews: Int
  backImg: String
  icon: String
}

input TopicUpdateWithWhereUniqueWithoutPostsInput {
  where: TopicWhereUniqueInput!
  data: TopicUpdateWithoutPostsDataInput!
}

input TopicUpsertWithoutEventsInput {
  update: TopicUpdateWithoutEventsDataInput!
  create: TopicCreateWithoutEventsInput!
}

input TopicUpsertWithWhereUniqueWithoutPostsInput {
  where: TopicWhereUniqueInput!
  update: TopicUpdateWithoutPostsDataInput!
  create: TopicCreateWithoutPostsInput!
}

input TopicWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  events_every: EventWhereInput
  events_some: EventWhereInput
  events_none: EventWhereInput
  coverImg: String
  coverImg_not: String
  coverImg_in: [String!]
  coverImg_not_in: [String!]
  coverImg_lt: String
  coverImg_lte: String
  coverImg_gt: String
  coverImg_gte: String
  coverImg_contains: String
  coverImg_not_contains: String
  coverImg_starts_with: String
  coverImg_not_starts_with: String
  coverImg_ends_with: String
  coverImg_not_ends_with: String
  coverDescription: String
  coverDescription_not: String
  coverDescription_in: [String!]
  coverDescription_not_in: [String!]
  coverDescription_lt: String
  coverDescription_lte: String
  coverDescription_gt: String
  coverDescription_gte: String
  coverDescription_contains: String
  coverDescription_not_contains: String
  coverDescription_starts_with: String
  coverDescription_not_starts_with: String
  coverDescription_ends_with: String
  coverDescription_not_ends_with: String
  numViews: Int
  numViews_not: Int
  numViews_in: [Int!]
  numViews_not_in: [Int!]
  numViews_lt: Int
  numViews_lte: Int
  numViews_gt: Int
  numViews_gte: Int
  backImg: String
  backImg_not: String
  backImg_in: [String!]
  backImg_not_in: [String!]
  backImg_lt: String
  backImg_lte: String
  backImg_gt: String
  backImg_gte: String
  backImg_contains: String
  backImg_not_contains: String
  backImg_starts_with: String
  backImg_not_starts_with: String
  backImg_ends_with: String
  backImg_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TopicWhereInput!]
  OR: [TopicWhereInput!]
  NOT: [TopicWhereInput!]
}

input TopicWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  userType: UserType!
  name: String!
  openId: String!
  alias: String!
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean!
  level: levelType!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  userType: UserType!
  name: String!
  openId: String!
  alias: String!
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType!
  posts: PostCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutAuthorInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  id: ID
  userType: UserType!
  name: String!
  openId: String!
  alias: String!
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType!
  posts: PostCreateManyWithoutOwnerInput
}

input UserCreateWithoutPostsInput {
  id: ID
  userType: UserType!
  name: String!
  openId: String!
  alias: String!
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType!
  comments: CommentCreateManyWithoutAuthorInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  userType_ASC
  userType_DESC
  name_ASC
  name_DESC
  openId_ASC
  openId_DESC
  alias_ASC
  alias_DESC
  profileImg_ASC
  profileImg_DESC
  initialLetter_ASC
  initialLetter_DESC
  isHeavyUser_ASC
  isHeavyUser_DESC
  level_ASC
  level_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  userType: UserType!
  name: String!
  openId: String!
  alias: String!
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean!
  level: levelType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

enum UserType {
  GITHUB
  GOOGLE
}

input UserUpdateDataInput {
  userType: UserType
  name: String
  openId: String
  alias: String
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType
  posts: PostUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateInput {
  userType: UserType
  name: String
  openId: String
  alias: String
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType
  posts: PostUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  userType: UserType
  name: String
  openId: String
  alias: String
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCommentsDataInput {
  userType: UserType
  name: String
  openId: String
  alias: String
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType
  posts: PostUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutPostsDataInput {
  userType: UserType
  name: String
  openId: String
  alias: String
  profileImg: String
  initialLetter: String
  isHeavyUser: Boolean
  level: levelType
  comments: CommentUpdateManyWithoutAuthorInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  userType: UserType
  userType_not: UserType
  userType_in: [UserType!]
  userType_not_in: [UserType!]
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  openId: String
  openId_not: String
  openId_in: [String!]
  openId_not_in: [String!]
  openId_lt: String
  openId_lte: String
  openId_gt: String
  openId_gte: String
  openId_contains: String
  openId_not_contains: String
  openId_starts_with: String
  openId_not_starts_with: String
  openId_ends_with: String
  openId_not_ends_with: String
  alias: String
  alias_not: String
  alias_in: [String!]
  alias_not_in: [String!]
  alias_lt: String
  alias_lte: String
  alias_gt: String
  alias_gte: String
  alias_contains: String
  alias_not_contains: String
  alias_starts_with: String
  alias_not_starts_with: String
  alias_ends_with: String
  alias_not_ends_with: String
  profileImg: String
  profileImg_not: String
  profileImg_in: [String!]
  profileImg_not_in: [String!]
  profileImg_lt: String
  profileImg_lte: String
  profileImg_gt: String
  profileImg_gte: String
  profileImg_contains: String
  profileImg_not_contains: String
  profileImg_starts_with: String
  profileImg_not_starts_with: String
  profileImg_ends_with: String
  profileImg_not_ends_with: String
  initialLetter: String
  initialLetter_not: String
  initialLetter_in: [String!]
  initialLetter_not_in: [String!]
  initialLetter_lt: String
  initialLetter_lte: String
  initialLetter_gt: String
  initialLetter_gte: String
  initialLetter_contains: String
  initialLetter_not_contains: String
  initialLetter_starts_with: String
  initialLetter_not_starts_with: String
  initialLetter_ends_with: String
  initialLetter_not_ends_with: String
  isHeavyUser: Boolean
  isHeavyUser_not: Boolean
  level: levelType
  level_not: levelType
  level_in: [levelType!]
  level_not_in: [levelType!]
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    